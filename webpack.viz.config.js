const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const NodePolyfillPlugin = require("node-polyfill-webpack-plugin");

const ASSETS_PATH = __dirname + "/resources/frontend_client/app/assets";
const FONTS_PATH = __dirname + "/resources/frontend_client/app/fonts";
const TYPES_SRC_PATH = __dirname + "/frontend/src/metabase-types";
const SRC_PATH = __dirname + "/frontend/src/metabase";
const BUILD_PATH = __dirname + "/resources/frontend_client";
const CLJS_SRC_PATH = __dirname + "/frontend/src/cljs_release";
const LIB_SRC_PATH = __dirname + "/frontend/src/metabase-lib";
const ENTERPRISE_SRC_PATH =
  __dirname + "/enterprise/frontend/src/metabase-enterprise";

const WEBPACK_BUNDLE = process.env.WEBPACK_BUNDLE || "development";
const devMode = WEBPACK_BUNDLE !== "production";

const BABEL_CONFIG = {
  cacheDirectory: process.env.BABEL_DISABLE_CACHE ? null : ".babel_cache",
};

const CSS_CONFIG = {
  localIdentName: devMode
    ? "[name]__[local]___[hash:base64:5]"
    : "[hash:base64:5]",
  importLoaders: 1,
};

module.exports = env => {
  const shouldDisableMinimization = devMode || env.WEBPACK_WATCH === true;

  return {
    mode: "production",
    context: SRC_PATH,

    performance: {
      hints: false,
    },

    entry: {
      "lib-viz": {
        import: "./lib-viz.js",
        library: {
          name: "Visualization",
          type: "var",
        },
      },
    },

    output: {
      path: BUILD_PATH + "/app/dist",
      filename: "[name].bundle.js",
      library: 'Visualization',
      libraryTarget: 'umd',
    },

    module: {
      rules: [
        {
          test: /\.(tsx?|jsx?)$/,
          exclude: /node_modules|cljs/,
          use: [{ loader: "babel-loader", options: BABEL_CONFIG }],
        },
        {
          test: /\.(eot|woff2?|ttf|svg|png)$/,
          type: "asset/resource",
        },
        {
          test: /\.css$/,
          use: [
            {
              loader: MiniCssExtractPlugin.loader,
              options: {
                publicPath: "./",
              },
            },
            { loader: "css-loader", options: CSS_CONFIG },
            { loader: "postcss-loader" },
          ],
        },
        {
          test: /\.js$/,
          exclude: /node_modules/,
          enforce: "pre",
          use: ["source-map-loader"],
        },
      ],
    },
    resolve: {
      extensions: [
        ".webpack.js",
        ".web.js",
        ".js",
        ".jsx",
        ".ts",
        ".tsx",
        ".css",
        ".svg",
      ],
      alias: {
        assets: ASSETS_PATH,
        fonts: FONTS_PATH,
        "metabase-types": TYPES_SRC_PATH,
        metabase: SRC_PATH,
        cljs: CLJS_SRC_PATH,
        "metabase-lib": LIB_SRC_PATH,
        style: SRC_PATH + "/css/core/index",
        ace: __dirname + "/node_modules/ace-builds/src-min-noconflict", "ee-plugins":
        process.env.MB_EDITION === "ee"
          ? ENTERPRISE_SRC_PATH + "/plugins"
          : SRC_PATH + "/lib/noop",
      "ee-overrides":
        process.env.MB_EDITION === "ee"
          ? ENTERPRISE_SRC_PATH + "/overrides"
          : SRC_PATH + "/lib/noop",
      },
    },
    optimization: {
      minimize: !shouldDisableMinimization,
    }, 
    
    plugins: [
      // Extracts initial CSS into a standard stylesheet that can be loaded in parallel with JavaScript
      // NOTE: the filename on disk won't include "?[chunkhash]" but the URL in index.html generated by HtmlWebpackPlugin will:
      new MiniCssExtractPlugin({
        filename: devMode ? "[name].css" : "[name].css?[contenthash]",
        chunkFilename: devMode ? "[id].css" : "[id].css?[contenthash]",
      }),
      new NodePolyfillPlugin(), // for crypto, among others
    ]
  };
};
